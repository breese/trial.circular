:doctype: book
:toc: left
:toclevels: 2
:source-highlighter: pygments
:source-language: C++
:prewrap!:
:pygments-style: vs
:icons: font

= Circular Span

[NOTE]
.Precondition
====
[source,c++]
----
namespace circular = trial::circular;
----
====

== Introduction

The `circular::span<T>` template class is a span that turns continguous storage
into a double-ended circular queue.

[cols="20,80",frame="none",grid="none",stripes=none]
|===
| Span | The storage is not owned by the span. The owner of the storage is
   responsible for destroying the span before releasing the storage.
| Circular | Inserting elements into the span will remove elements at the
   other end of the span when the span is full. If elements always are inserted
   at the same end, then we effectively have a moving window over the most
   recent elements.
| Double-ended | Elements can be inserted either at the beginning or the end
   of the span. This enables fixed-sized first-in-first-out or last-in-first-out
   usages.
| Queue | Elements can only be inserted and erased at the beginning or end of
   the span.
|===

[#span-tutorial]
== Tutorial

=== Running Average

Suppose we receive a sequence of numerical values one by one over time, and we
want to calculate the running average of the `N` most recent values. Our class
should at least support the following interface for inserting new values and
for returning the current mean.
[source,c++,numbered]
----
template <typename T, std::size_t N>
class average
{
public:
    using value_type = T; 

    average() noexcept;

    // Insert new value
    void push(value_type value) noexcept;
    // Return current mean
    value_type mean() const noexcept;
};
----
When we insert a new value, the oldest value must be removed from our running
average, so we have to remember the `N` most recent values.
We therefore want to reserve storage for `N` values, and have an efficient way
of inserting new values and removing old values from this storage.
We are going to use a circular span (`circular::span<value_type, N> window`)
that uses an array (`value_type storage[N]`) as storage.
[source,c++,numbered]
----
template <typename T, std::size_t N>
class average
{
public:
    using value_type = T; 

    average() noexcept;

    void push(value_type input) noexcept;
    value_type mean() const noexcept;

private:
    static_assert(N > 0, "N must be greater than zero");
    value_type sum = {};
    value_type storage[N];
    circular::span<value_type, N> window;
};
----
We start by initializing the circular span to use the array as storage.
[source,c++,numbered]
----
template <typename T, std::size_t N>
average::average()
    : window(storage) // Instruct span to use storage
{
}
----
Notice that the array is automatically filled with default-constructed elements.
These will be overwritten one by one when inserting new values into the window.

When new values are inserted we first update the running sum. This is done by
undoing the effect of the oldest value (`window.front()`) if the window is
full. There is a pre-condition for `span<T, N>::front()` that it can only be
called if the window is not empty; this is guaranteed by the call to `window.full()`.

Afterwards we store the input value in the window (`window.push_back(input)`)
such that we can undo its effect when it later leaves the window. As the
`push_back()` function overwrites the oldest value at the front, it is important
that we update the running sum before we store the input value.
[source,c++,numbered]
----
template <typename T, std::size_t N>
void average::push(value_type input) noexcept
{
    // Update the current mean
    if (window.full())
    {
        sum += input - window.front();
    }
    else
    {
        sum += input;
    }
    // Remember the input value for later use
    window.push_back(input);
}
----
The current mean is the calculated as the running sum divided by the number of
elements in the window.
[source,c++,numbered]
----
template <typename T, std::size_t N>
T average::mean() const noexcept
{
    assert(!window.empty());

    return sum / window.size();
}
----

[#span-rationale]
== Design Rationale

This section describes the choices behind the design of the circular span.

[#rationale-extent]
=== Extent

The extent is an optional template argument that specifies the capacity of the
span at compile-time. The capacity is part of the span type and therefore does
not have to be stored as a member variable.

If the `Extent` template argument is omitted, or specified as `dynamic_extent`,
the capacity is determined when the span is constructed. The capacity does not
change after construction, unless the span is recreated by assignment. For this
case, the capacity is stored as a member variable.

The extent has been introduced for alignment with `std::span<T, Extent>`.

[#rationale-lazy-destruction]
=== Lazy Destruction

The circular queue uses a lazy destruction policy when elements are removed
from the queue.
The removed elements are not destroyed immediately but linger in the underlying
storage until they are overwritten by an insertion, or the underlying storage
is destroyed.

 * When elements are removed by `remove_front()` or `remove_back()` they are
   left untouched in the underlying storage. Only the internal state of the
   span is modified.

 * When elements are popped by `pop_front()` or `pop_back()` they are left in
   a moved-from state in the underlying storage.

In both cases the removed elements in the underlying storage are left in an
unspecified but valid state, which enables us to overwrite them later on.

The reason is that the storage is contiguous, so there have to be some unused
elements in the storage. The removed elements are therefore left in their
position in the storage, and only destroyed when when the position is needed
by another insertion.
The removed elements are not replaced by some default element for performance
reasons.

[#rationale-subspans]
=== Subspans

Circular span supports subspans, but unlike `std::span` a subspans of a circular
span is not another circular span. Creating a circular span must be done on
contiguous storage. Although circular span operates on contiguous storage, the
range from `begin()` until `end()` is not guaranteed to be contiguous as it may
wrap around the underlying storage. In other words, a circular span cannot be
constructed from another circular span.

Instead `span<T>::const_segment` is used to represent subspans. The type fulfills
the _BidirectionalRange_ requirements, which means that it has `begin()` and
`end()` functions returning a _BidirectionalIterator_. Beyond that, the type is
unspecified.

There are two member functions that returns a subspan: `front_segment()` returns
a range of all contiguous elements starting from the front of the span, and
`back_segment` returns a range of any left-over elements that have been wrapped
around in the underlying storage.
This functionality is useful for use cases such as zero-copy network transmission
of the circular span.

While `front_segment()` and `back_segment()` returns segments of contiguous storage
and therefore could have returned a circular span, this is not necessarily the
case for other kinds of subspans we may want to add. However, as the circular span
itself fulfills the _BidirectionalRange_ we could choose to implement `const_segment`
in terms of circular span, although a more lean span type, like `std::span` would
be a more prudent choice.

[#ref]
== Reference

Defined in header `<trial/circular/span.hpp>`.

Defined in namespace `trial::circular`.
[source,c++]
----
template <
    typename T,
    std::size_t Extent = dynamic_extent
> class span;
----
The circular span template class is a circular view of some contiguous storage.
The storage is not owned by the span. The owner must ensure that the span is
destroyed before the storage is released.

The size is the current number of elements in the span.

The capacity is the maximum number of elements that can be inserted without
overwriting old elements. The capacity cannot be changed.

The extent determines the capacity of the span.
With `dynamic_extent` the capacity is derived from the input arguments
at construction or assignment time. Otherwise the capacity is fixed to the
specified `Extent` template argument. Dynamic extent is used by default.

=== Template arguments

[frame="topbot",grid="rows",stripes=none]
|===
| `T` | Element type.
 +
 +
 _Constraint:_ `T` must be a complete type.
| `Extent` | The maximum number of elements in the span.
|===

=== Member types

[%header,frame="topbot",grid="rows",stripes=none]
|===
| Member type | Definition
| `element_type` | `T`
| `value_type` | `std::remove_cv_t<T>`
| `size_type` | `std::size_t`
| `pointer` | `element_type*`
| `reference` | `element_type&`
| `const_reference` | `const element_type&`
| `const_iterator` | _BidirectionalIterator_ with `const value_type`
| `const_reverse_iterator` | `std::reverse_iterator<const_iterator>`
| `const_segment` | _BidirectionalRange_ with `const value_type`
|===

=== Member functions

[%header,frame="topbot",grid="rows",stripes=none]
|===
| Member function | Description
| `constexpr span() noexcept` | Creates an empty span with zero capacity.
 +
 +
 No elements can be inserted into a zero-capacity span. The span must be recreated before use.
 +
 +
 _Ensures:_ `capacity() == 0`
 +
 _Ensures:_ `size() == 0`
| `constexpr span(const span& other) noexcept` | Creates a span by copying.
 +
 +
 _Ensures:_ `capacity() == other.capacity()`
 +
 _Ensures:_ `size() == other.size()`
| `constexpr span(span&& other) noexcept` | Creates span by moving.
 +
 +
 The state of the moved-from span is valid but undefined.
 +
 +
 _Ensures:_ `capacity() == other.capacity()`
 +
 _Ensures:_ `size() == other.size()`
| `template <typename U, std::size_t N>
 +
 explicit constexpr span(const span<U, N>& other) noexcept` | Creates a span by copying from convertible value type or compatible extent.
 +
 +
 Enables copying a mutable span into an immutable span, or copying a span with fixed extent into a span with dynamic extent.
 +
 +
 _Constraint:_ `Extent == N` or `Extent == dynamic_extent`
 +
 _Constraint:_ `U` is convertible to `T`
 +
 +
 _Ensures:_ `capacity() == other.capacity()`
 +
 _Ensures:_ `size() == other.size()`
| `template <typename ContiguousIterator>
 +
 constexpr span(ContiguousIterator begin, ContiguousIterator end) noexcept` | Creates a span from iterators.
 +
 +
 _Expects:_ `Extent == std::distance(begin, end)` or `Extent == dynamic_extent`
 +
 +
 _Ensures:_ `capacity() == std::distance(begin, end)`
 +
 _Ensures:_ `size() == std::distance(begin, end)`
| `template <typename ContiguousIterator>
 +
 constexpr span(ContiguousIterator begin, ContiguousIterator end, ContiguousIterator first, size_type length) noexcept` | Creates a span from iterators and initializes the span with the pre-existing `length` elements starting at `first`.
 +
 +
 _Expects:_ `Extent == std::distance(begin, end)` or `Extent == dynamic_extent`
 +
 _Expects:_ `first` is within the range `[begin; end]`
 +
 _Expects:_ `length \<= std::distance(first, end)`
 +
 +
 _Ensures:_ `capacity() == std::distance(begin, end)`
 +
 _Ensures:_ `size() == length`
| `template <std::size_t N>
 +
 explicit constexpr span(value_type (&)[N]) noexcept` | Creates empty span from an array object with compatible extent.
 +
 +
 _Constraint:_ `Extent == N` or `Extent == dynamic_extent`
 +
 +
 _Ensures:_ `capacity() == N`
 +
 _Ensures:_ `size() == 0`
| `constexpr{wj}footnote:constexpr11[Not constexpr in pass:[C++11].] span& operator=(const span& other) noexcept` | Recreates span by copying.
 +
 +
 _Ensures:_ `capacity() == other.capacity()`
 +
 _Ensures:_ `size() == other.size()`
| `constexpr{wj}footnote:constexpr11[] span& operator=(span&&) noexcept` | Recreates span by moving.
 +
 +
 The state of the moved-from span is valid but undefined.
 +
 +
 _Ensures:_ `capacity() == other.capacity()`
 +
 _Ensures:_ `size() == other.size()`
| `constexpr{wj}footnote:constexpr11[] span& operator=(std::initializer_list<value_type> input) noexcept(_see Remarks_)` | Replaces span with elements from initializer list.
 +
 +
 Capacity is unchanged.
 +
 +
 _Constraint:_ `value_type` must be _MoveAssignable_.
 +
 +
 _Ensures:_ `size() == std::min(input.size(), capacity())`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveAssignable_.
| `constexpr bool empty() const noexcept` | Checks if span is empty.
| `constexpr bool full() const noexcept` | Checks if span is full.
| `constexpr size_type capacity() const noexcept` | Returns the maximum possible number of elements in the span.
| `constexpr size_type size() const noexcept` | Returns the number of elements in the span.
| `constexpr{wj}footnote:constexpr11[] reference front() noexcept` | Returns a reference to the first element in the span.
 +
 +
 _Expects:_ `size() > 0`
| `constexpr const_reference front() const noexcept` | Returns a constant reference to the first element in the span.
 +
 +
 _Expects:_ `size() > 0`
| `constexpr{wj}footnote:constexpr11[] reference back() noexcept` | Returns a reference to the last element in the span.
 +
 +
 _Expects:_ `size() > 0`
| `constexpr const_reference back() const noexcept` | Returns a constant reference to the last element in the span.
 +
 +
 _Expects:_ `size() > 0`
| `constexpr const_segment front_segment() const noexcept` | Returns a range of the first contiguous segment of the span.
 +
 +
 The front segment covers all elements from the beginning of the span until the end of the
 underlying storage if the span crosses the end of the storage; otherwise until the end of
 the span.
 +
 +
 An empty segment is returned if the span is empty.
 +
 +
 _Expects:_ `capacity() > 0`
| `constexpr const_segment back_segment() const noexcept` | Returns a range of the last contiguous segment of the span.
 +
 +
 The back segment covers the remaining elements not covered by the front segment.
 +
 +
 An empty segment is returned if the span is empty or does not cross the end of the
 underlying storage. Otherwise, the back segment starts at the beginning of the underlying
 storage and ends at the end of the span.
 +
 +
 _Expects:_ `capacity() > 0`
| `constexpr{wj}footnote:constexpr11[] reference operator[](size_type position) noexcept` | Returns a reference to the element at the given position in the span.
 +
 +
 _Expects:_ `position < size()`
| `constexpr const_reference operator[](size_type position) const noexcept` | Returns a reference to the element at the given position in the span.
 +
 +
 _Expects:_ `position < size()`
| `constexpr{wj}footnote:constexpr11[] void clear() noexcept` | Clears the span.
 +
 +
 The elements are not destroyed in the underlying storage.
 +
 +
 _Ensures:_ `size() == 0`
| `template <typename InputIterator>
 +
 constexpr{wj}footnote:constexpr11[] void assign(InputIterator first, InputIterator last) noexcept(_see Remarks_)` | Replaces the span with elements from iterator range.
 +
 +
 _Constraint:_ `value_type` must be _CopyAssignable_.
 +
 +
 _Ensures:_ `size() == std::min(std::distance(first, last), capacity())`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _CopyAssignable_.
| `constexpr{wj}footnote:constexpr11[] void assign(std::initializer_list<value_type> input) noexcept(_see Remarks_)` | Replaces the span with elements from initializer list.
 +
 +
 _Constraint:_ `value_type` must be _MoveAssignable_.
 +
 +
 _Ensures:_ `size() == std::min(input.size(), capacity())`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveAssignable_.
| `constexpr{wj}footnote:constexpr11[] void push_front(value_type) noexcept(_see Remarks_)` | Inserts an element at the beginning of the span.
 +
 +
 If the span is full, then the element at the end of the span is silently erased to make room for new element.
 +
 +
 _Constraint:_ `value_type` must be _MoveAssignable_.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveAssignable_.
| `template <typename InputIterator>
 +
 constexpr{wj}footnote:constexpr11[] void push_front(InputIterator first, InputIterator last) noexcept(_see Remarks_)` | Inserts elements from iterator range at the beginning of the span.
 +
 +
 _Constraint:_ `value_type` must be _CopyAssignable_.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _CopyAssignable_.
| `constexpr{wj}footnote:constexpr11[] void push_back(value_type) noexcept(_see Remarks_)` | Inserts an element at the end of the span.
 +
 +
 If the span is full, then the element at the beginning of the span is silently erased to make room for new element.
 +
 +
 _Constraint:_ `value_type` must be _MoveAssignable_.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveAssignable_.
| `template <typename InputIterator>
 +
 constexpr{wj}footnote:constexpr11[] void push_back(InputIterator first, InputIterator last) noexcept(_see Remarks_)` | Inserts elements from iterator range at the end of the span.
 +
 +
 _Constraint:_ `value_type` must be _CopyAssignable_.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _CopyAssignable_.
| `constexpr{wj}footnote:constexpr11[] value_type pop_front() noexcept(_see Remarks_)` | Removes and returns an element from the beginning of the span.
 +
 +
 The removed element in the underlying storage is left in a moved-from state.
 +
 +
 If the return value is unused, then `remove_front()` is a more efficient method for removing the front element.
 +
 +
 _Expects:_ `size() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveConstructible_.
| `constexpr{wj}footnote:constexpr11[] value_type pop_back() noexcept(_see Remarks_)` | Removes and returns an element from the end of the span.
 +
 +
 The removed element in the underlying storage is left in a moved-from state.
 +
 +
 If the return value is unused, then `remove_back()` is a more efficient method for removing the back element.
 +
 +
 _Expects:_ `size() > 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _MoveConstructible_.
| `constexpr{wj}footnote:constexpr11[] void append_front() noexcept`
 +
 +
 `constexpr{wj}footnote:constexpr11[] void append_front(size_type count) noexcept`
 | Inserts the given number of unspecified elements at the beginning of the span.
 +
 +
 The default value of `count` is 1 if omitted.
 +
 +
 Makes room for `count` elements at the front. The inserted elements are in an unspecified but valid state.
 +
 +
 If the span is full, then the elements are taken from the end of the span. This effectively rotates the span without touching the elements in the underlying storage. Otherwise, the span is enlarged.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 _Expects:_ `count \<= capacity()`
 +
 +
 _Ensures:_ `size() >= count`
|  `constexpr{wj}footnote:constexpr11[] void append_back() noexcept`
 +
 +
 `constexpr{wj}footnote:constexpr11[] void append_back(size_type count) noexcept`
 | Inserts the given number of unspecified elements at the end of the span.
 +
 +
 The default value of `count` is 1 if omitted.
 +
 +
 Makes room for `count` elements at the back. The inserted elements are in an unspecified but valid state.
 +
 +
 If the span is full, then the elements are taken from the beginning of the span. This effectively rotates the span without touching the elements in the underlying storage. Otherwise, the span is enlarged.
 +
 +
 _Expects:_ `capacity() > 0`
 +
 _Expects:_ `count \<= capacity()`
 +
 +
 _Ensures:_ `size() >= count`
|  `constexpr{wj}footnote:constexpr11[] void remove_front() noexcept`
 +
 +
 `constexpr{wj}footnote:constexpr11[] void remove_front(size_type count) noexcept`
 | Removes the given number of elements from the beginning of the span.
 +
 +
 The default value of `count` is 1 if omitted.
 +
 +
 The removed elements are not destroyed in the underlying storage.
 +
 +
 _Expects:_ `size() > 0`
 +
 _Expects:_ `count \<= size()`
 +
 +
 _Ensures:_ `capacity() - size() >= count`
| `constexpr{wj}footnote:constexpr11[] void remove_back() noexcept`
 +
 +
 `constexpr{wj}footnote:constexpr11[] void remove_back(size_type count) noexcept`
 | Removes the given number of elements from the end of the span.
 +
 +
 The default value of `count` is 1 if omitted.
 +
 +
 The removed elements are not destroyed in the underlying storage.
 +
 +
 _Expects:_ `size() > 0`
 +
 _Expects:_ `count \<= size()`
 +
 +
 _Ensures:_ `capacity() - size() >= count`
| `constexpr{wj}footnote:constexpr11[] void rotate_front() noexcept(_see Remarks_)`
 | Moves elements such that the span starts at the beginning of the storage.
 +
 +
 Rotation does not alter the sequence of elements in the span. It only rearranges elements in
 the underlying storage such that first element in the span is located at the first position
 in the storage. This ensures that the elements are stored contiguously. Consequently the
 back segment will be empty.
 +
 +
 Rotation invalidates pointers and references, but does not invalidate iterators.
 +
 +
 _Ensures:_ `std::distance(back_segment().begin(), back_segment.end()) == 0`
 +
 +
 _Remarks:_ `noexcept` if `value_type` is nothrow _Swappable_.
| `constexpr{wj}footnote:constexpr11[] iterator begin() noexcept`
 +
 +
 `constexpr const_iterator begin() const noexcept`
 +
 +
 `constexpr const_iterator cbegin() const noexcept`
 | Returns an interator to the beginning of the span.
| `constexpr{wj}footnote:constexpr11[] iterator end() noexcept`
 +
 +
 `constexpr const_iterator end() const noexcept`
 +
 +
 `constexpr const_iterator cend() const noexcept`
 | Returns an interator to the end of the span.
| `constexpr{wj}footnote:constexpr11[] reverse_iterator rbegin() noexcept`
 +
 +
 `constexpr const_reverse_iterator rbegin() const noexcept`
 +
 +
 `constexpr const_reverse_iterator crbegin() const noexcept`
 | Returns a reverse interator to the beginning of the span.
| `constexpr{wj}footnote:constexpr11[] reverse_iterator rend() noexcept`
 +
 +
 `constexpr const_reverse_iterator rend() const noexcept`
 +
 +
 `constexpr const_reverse_iterator crend() const noexcept`
 | Returns a reverse interator to the end of the span.
|===

=== Non-member constants
[frame="topbot",grid="rows"]
|===
| `dynamic_extent` | A constant of type `std::size_t` to specify a span with dynamic extent.
|===
